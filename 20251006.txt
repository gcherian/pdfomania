flowchart LR
  subgraph User["Ops Analyst"]
    U1[Reviews case in Indigo/Core]
    U2[Opens QC Panel (sidecar)]
  end

  subgraph Systems["Source Systems"]
    IND[Indigo (Transactions)]
    CORE[Core Banking (Accounts, Balances)]
    ICMP[ICMP (Docs, DocAI JSON)]
  end

  subgraph Overlay["QC Overlay (New)"]
    FE[QC Frontend (client.ts)]
    API[QC API (server.py)]
    RULES[Rules/AI Validator]
    DB[(QC Store)]
    FILES[(Evidence Store)]
    AUDIT[(Audit Log)]
  end

  U1 -->|case id| FE
  U2 --> FE

  FE <--> API
  API --> DB
  API -.-> AUDIT
  API --> RULES
  API -->|read-only adapters| IND
  API -->|read-only adapters| CORE
  API -->|Doc & bbox refs| ICMP
  FE -->|upload/attach| FILES

  RULES --> DB
  DB --> FE

sequenceDiagram
  participant Analyst
  participant FE as QC Frontend
  participant API as QC API
  participant IND as Indigo
  participant CORE as Core
  participant ICMP as ICMP/DocAI
  participant RULES as Rules/AI
  participant DB as QC Store

  Analyst->>FE: Open MACP/SSI case (case_id)
  FE->>API: GET /qc/questions?case_id=...
  API->>IND: fetch txn / remittance context
  API->>CORE: fetch ledger/open item state
  API->>ICMP: fetch doc list + DocAI bboxes
  API-->>FE: questions + prefilled hints

  Analyst->>FE: selects evidence (doc page+bbox)
  FE->>API: POST /qc/log {question, answer, evidence}
  API->>RULES: validate(answer, system_state, evidence)
  RULES-->>API: {qc_passed, reason, expected}
  API->>DB: persist decision + result
  API-->>FE: {qc_passed: true/false, reason}

  FE->>API: GET /qc/summary?case_id=...
  API-->>FE: pass/fail, timings, exceptions


# server.py (FastAPI-style pseudocode; adapt to your stack)
from fastapi import FastAPI, UploadFile, File
from pydantic import BaseModel
from typing import List, Optional
from datetime import datetime

app = FastAPI()

class Evidence(BaseModel):
    source: str           # "ICMP", "Indigo", "Core"
    document_id: Optional[str] = None
    page: Optional[int] = None
    bbox: Optional[list] = None   # [x1,y1,x2,y2] normalized (0..1)
    note: Optional[str] = None

class QCEntry(BaseModel):
    case_id: str
    flow: str             # "MACP" | "SSI"
    question_id: str
    question_text: str
    answer: str           # "Yes/No" or value
    user_id: str
    evidence: Optional[Evidence] = None
    ts: datetime = datetime.utcnow()

class QCCheckResult(BaseModel):
    qc_passed: bool
    severity: str         # "INFO" | "WARN" | "FAIL"
    reason: Optional[str] = None
    expected: Optional[str] = None

@app.get("/qc/questions")
def questions(case_id: str, flow: str):
    # Pull system context to tailor questions/hints
    indigo = fetch_indigo(case_id)
    core = fetch_core(case_id)
    icmp  = fetch_icmp_docs(case_id)
    return {
        "case_id": case_id,
        "flow": flow,
        "questions": [
          {"id":"macp.match_open_item","text":"Does payment match an open item in Core?","type":"yesno","hint": indigo.get("open_item_hint")},
          {"id":"macp.currency_ok","text":"Is currency correct?","type":"yesno","hint": core.get("currency")},
          {"id":"macp.remittance_present","text":"Is remittance advice attached?","type":"yesno","hint": icmp.get("likely_page_bbox")}
        ],
        "docs": icmp["docs"],  # list of {document_id, pages, docai_json_url}
    }

@app.post("/qc/log")
def qc_log(entry: QCEntry):
    # Persist raw human decision
    save_qc_entry(entry.dict())
    # Validate
    result = validate(entry)  # returns QCCheckResult
    # Persist outcome
    save_qc_result(entry.case_id, entry.question_id, result.dict())
    # Audit write-behind
    write_audit("qc_log", entry.user_id, entry.case_id, entry.question_id, result.qc_passed)
    return {"status":"ok","result":result}

@app.get("/qc/summary")
def qc_summary(case_id: str):
    return build_case_summary(case_id)

@app.post("/evidence/upload")
def upload(file: UploadFile = File(...), case_id: str = "", note: str = ""):
    url = store_file(file, case_id)
    return {"status":"ok","url":url}

# --- Validation rules (seed set; expand during week)
def validate(entry: QCEntry) -> QCCheckResult:
    if entry.question_id == "macp.match_open_item":
        expected = core_expected_open_item(entry.case_id)
        passed = str(entry.answer).lower() in ["yes","true"] if expected else str(entry.answer).lower() in ["no","false"]
        return QCCheckResult(qc_passed=passed, severity="FAIL" if not passed else "INFO",
                             reason=None if passed else "Open item mismatch",
                             expected="Open item exists" if expected else "No open item")
    if entry.question_id == "macp.currency_ok":
        expected = core_currency(entry.case_id)
        passed = entry.answer.upper() == "YES" and expected == "OK"
        return QCCheckResult(qc_passed=passed, severity="WARN" if not passed else "INFO",
                             reason=None if passed else f"Currency expected {expected}",
                             expected=expected)
    # default
    return QCCheckResult(qc_passed=True, severity="INFO")


// client.ts (React-like pseudocode)
type Question = { id:string; text:string; type:"yesno"|"text"; hint?:any };
type Evidence = { source:"ICMP"|"Indigo"|"Core"; document_id?:string; page?:number; bbox?:number[]; note?:string };

export function QCPanel({ caseId, flow }:{
  caseId:string; flow:"MACP"|"SSI"
}) {
  const [questions, setQuestions] = useState<Question[]>([]);
  const [docs, setDocs] = useState<any[]>([]);
  const [answers, setAnswers] = useState<Record<string, string>>({});
  const [evidence, setEvidence] = useState<Record<string, Evidence>>({});
  const [results, setResults] = useState<Record<string, any>>({});

  useEffect(() => {
    fetch(`/qc/questions?case_id=${caseId}&flow=${flow}`)
      .then(r => r.json())
      .then(d => { setQuestions(d.questions); setDocs(d.docs); });
  }, [caseId, flow]);

  const submit = async (q: Question) => {
    const body = {
      case_id: caseId,
      flow,
      question_id: q.id,
      question_text: q.text,
      answer: answers[q.id],
      user_id: window.currentUser,
      evidence: evidence[q.id]
    };
    const res = await fetch("/qc/log", { method:"POST", headers:{ "Content-Type":"application/json" }, body: JSON.stringify(body) }).then(r=>r.json());
    setResults(prev => ({...prev, [q.id]: res.result}));
  };

  return (
    <div className="qc-panel">
      <header>
        <h3>QC: {flow} — {caseId}</h3>
      </header>

      <section className="questions">
        {questions.map(q => (
          <div className="q" key={q.id}>
            <div className="q-text">{q.text}</div>
            <div className="q-hint">Hint: {String(q.hint ?? "—")}</div>
            <div className="q-answer">
              <select onChange={e=>setAnswers(a=>({...a,[q.id]:e.target.value}))} defaultValue="">
                <option value="" disabled>Choose…</option>
                <option>Yes</option><option>No</option>
              </select>
            </div>
            <EvidencePicker docs={docs} onPick={(ev)=>setEvidence(e=>({...e,[q.id]:ev}))}/>
            <button onClick={()=>submit(q)}>Submit</button>
            {results[q.id] && (
              <div className={`qc-result ${results[q.id].qc_passed ? "pass" : "fail"}`}>
                {results[q.id].qc_passed ? "✅ Passed" : `❌ ${results[q.id].reason || "Failed"}`} 
                {results[q.id].expected ? ` (expected: ${results[q.id].expected})` : ""}
              </div>
            )}
          </div>
        ))}
      </section>

      <CaseSummary caseId={caseId}/>
    </div>
  );
}

// Sketch: lets user click a doc page to attach {page,bbox}
function EvidencePicker({ docs, onPick }:{ docs:any[]; onPick:(e:Evidence)=>void }) {
  // render page thumbnails with DocAI word boxes; on drag-select, emit normalized bbox
  return <div className="evidence-picker">Attach ICMP snippet or system ref…</div>;
}


erDiagram
    ROLE ||--o{ HUMAN_REVIEWER : "has"
    ROLE ||--o{ AI_AGENT_REVIEWER : "has"
    QA_ADMIN ||--o{ ROLE : "assigns"
    AI_AGENT_REVIEWER ||--o{ QA_CONTROL : "performs"
    HUMAN_REVIEWER ||--o{ QA_CONTROL : "performs"
    QA_CONTROL ||--o{ PROCESS : "validates"
    PROCESS ||--o{ DOCUMENT : "applies_to"
    DOCUMENT ||--o{ DOCUMENT_TYPE : "is_of"
    DOCUMENT ||--o{ QUESTION : "contains"
    QUESTION ||--o{ SOP_QUESTION : "maps_to"
    QUESTION ||--o{ VALIDATION_FIELD_NAME : "has"
    VALIDATION_FIELD_NAME ||--o{ VALIDATED_FIELD_VALUE : "produces"
    VALIDATED_FIELD_VALUE ||--o{ MANUAL_CORRECTION : "may_trigger"
    DOCUMENT ||--o{ DOCUMENTED_STATUS : "has"

    %% Optional attributes for readability
    QA_ADMIN {
        string name
        string role
    }
    AI_AGENT_REVIEWER {
        string name
        string model_id
    }
    HUMAN_REVIEWER {
        string name
        string expertise
    }
    DOCUMENT {
        string doc_id
        string doc_type
        string process_stage
    }
    QUESTION {
        string question_id
        string question_text
    }
    VALIDATION_FIELD_NAME {
        string field_name
    }
    VALIDATED_FIELD_VALUE {
        string value
        string confidence_score
    }


flowchart TB
    %% Swimlanes
    subgraph DATA["Data Layer"]
        A1["ECM Document Storage"] -->|Upload| A2["S3 Internal Document Storage"]
        A2 -->|Feed to| A3["MongoDB (QA Review Transaction Data)"]
    end

    subgraph APPLICATION["Application Layer"]
        B1["Orchestrate"] --> B2["Parse"]
        B2 --> B3["Validate"]
        B3 --> B4["Act"]
        B4 --> B5["Compose Response"]
        B5 -->|Retrieved Content| UI["User Interface (Human + AI)"]
        
        %% Agentic & Research Loop
        B3 --> B6["TACHYON-ADK (Google ADK)"]
        B6 --> B7["Agentic Research & Validation"]
    end

    subgraph INTEGRATION["Integration Layer"]
        C1["Wells Fargo Systems (CORE, InfoLease, S4SOT)"]
        C2["ICMP"]
        C3["Enterprise Classification"]
        C4["Epress API / Managed Document"]
        C5["MongoDB Client Driver"]
        
        C1 --> C2 --> C3 --> C4 --> C5
        C4 -->|Non-managed Docs| B2
        C1 -->|Managed Docs| B2
    end

    %% Links between layers
    A3 -->|QA Review Data| B3
    UI -->|Feedback Loop| B6
    B6 -->|Learning Updates| A3



flowchart TB
%% ----------------------------------------------------
%% LAYERS
%% ----------------------------------------------------
subgraph INTEGRATION["🔗 Integration"]
  C1["CORE / InfoLease / S4SOT"]
  C2["ICMP"]
  C3["Enterprise Classification"]
  C4["Epress API (Managed Docs)"]
  C5["MongoDB Client Driver"]
  C1 --> C2 --> C3 --> C4 --> C5
end

subgraph APPLICATION["⚙️ Application"]
  B1["Orchestrate"]
  B2["Parse"]
  B3["Validate"]
  B4["Act"]
  B5["Compose Response"]
  UI["User Interface (Human + AI)"]
  B1 --> B2 --> B3 --> B4 --> B5 --> UI
  B3 --> ADK["Agentic Research & Validation (ADK)"] --> B3
end

subgraph DATA["🧱 Data"]
  A1["ECM Document Storage"]
  A2["S3 Internal Document Storage"]
  A3["MongoDB (QA Review Txn Data)"]
  A1 -->|"Upload / Ingest"| A2
  A2 -->|"Write results / features"| A3
end

%% Cross-layer links
C4 -. Managed Docs .-> B2
C1 -. Non-managed Docs .-> B2
UI <-->|Feedback| ADK
A3 -->|"Historical QA context"| B3

%% ----------------------------------------------------
%% CONCEPTUAL DATA MODEL (as nodes)
%% ----------------------------------------------------
subgraph MODEL["🧠 Conceptual Data Model"]
  QA_ADMIN["QA Admin"]
  ROLE["Role"]
  HREV["Human Reviewer"]
  AIREV["AI Agent Reviewer"]
  QACTL["QA Control"]
  PROC["Process"]
  DOC["Document"]
  DOCTYPE["Document Type"]
  Q["Question"]
  SOPQ["SOP Question"]
  VFIELD["Validation Field Name"]
  VVALUE["Validated Field Value"]
  MCORR["Manual Correction"]
  DSTATUS["Documented Status"]

  %% Relationships inside the model cluster
  QA_ADMIN ---|"assigns"| ROLE
  ROLE ---|"has"| HREV
  ROLE ---|"has"| AIREV
  HREV ---|"performs"| QACTL
  AIREV ---|"performs"| QACTL
  QACTL ---|"validates"| PROC
  PROC ---|"applies_to"| DOC
  DOC ---|"is_of"| DOCTYPE
  DOC ---|"contains"| Q
  Q ---|"maps_to"| SOPQ
  Q ---|"has"| VFIELD
  VFIELD ---|"produces"| VVALUE
  VVALUE ---|"may_trigger"| MCORR
  DOC ---|"has"| DSTATUS
end

%% ----------------------------------------------------
%% BIND WORKFLOW <-> DATA MODEL
%% ----------------------------------------------------
B2 --"extracts / normalizes"--> DOC
B2 --"detects"--> DOCTYPE
B2 --"derives"--> Q

B3 --"runs"--> QACTL
B3 --"uses field defs"--> VFIELD
B3 --"computes"--> VVALUE
B3 --"updates"--> DSTATUS

B4 --"records"--> MCORR
B4 --"persists results"--> A3
B5 --"surfaces answers"--> UI

UI --"handled by"--> HREV
UI --"assisted by"--> AIREV

A3 --"stores"--> VVALUE
A3 --"stores"--> MCORR
A3 --"stores"--> DSTATUS
