flowchart LR
    subgraph Client["ðŸ–¥ï¸ UI (MACP/SSI Banner)"]
        UI[Batch Console\nâ€¢ Upload CSV\nâ€¢ Status (Processed/Pending/Failed)\nâ€¢ Doc detail + 'Explain'\nâ€¢ View Raw / View Reasoning]
    end

    subgraph BE["ðŸ§© Backend"]
        direction TB
        subgraph Dash["Dashboard Service"]
            API_DASH[REST: /dashboard, /batches, /docs/:id]
            CACHE[(Cache/Views)]
        end

        subgraph Proc["Data Processing Service"]
            API_PROC[REST: /batch/upload, /ecm/response]
            ORCH[Batch Orchestrator\nâ€¢ batch_id generation\nâ€¢ mapping table mgmt\nâ€¢ retries/timeouts]
            MAP[Response Mapper\n(batch_id âŸ· doc_id)\nsequence# fallback]
            LLM[LLM Reasoning Adapter\nâ€¢ prompt templates\nâ€¢ guardrails\nâ€¢ summaries]
            Q[[Queue/Events\n(ecm.request, ecm.reply)]]
        end
    end

    subgraph Data["ðŸ—„ï¸ Data Layer (Driver Pattern)"]
        MONGO[(MongoDB\nbatches, docs, responses, reasons)]
        JDBC[(JDBC Driver Slot\n(e.g., Symbols, Core))]
        FS[(Blob Store\n(raw files, ECM payloads))]
    end

    subgraph ECM["ðŸ¢ ECM / Extractors"]
        ecmIn[ECM Ingest API]
        ecmOut[ECM Callback (doc-by-doc)]
    end

    UI -- CSV / metadata --> API_PROC
    API_PROC --> ORCH --> Q
    Q --> ecmIn
    ecmOut --> API_PROC

    API_PROC --> MAP --> MONGO
    API_PROC --> FS
    API_PROC --> LLM --> MONGO

    API_DASH --> CACHE
    CACHE --> MONGO
    UI <-- status/analytics --> API_DASH

    %% Optional data sources
    Proc -. optional connectors .-> JDBC
    Proc -. raw payloads .-> FS

    classDef ui fill:#eaf5ff,stroke:#5aa3ff,stroke-width:1px;
    classDef be fill:#fff7e6,stroke:#ffb84d,stroke-width:1px;
    classDef data fill:#f1fff1,stroke:#7bd97b,stroke-width:1px;
    classDef ecm fill:#fff0f6,stroke:#ff85c0,stroke-width:1px;

    class UI ui
    class BE,Dash,Proc,API_DASH,CACHE,API_PROC,ORCH,MAP,LLM,Q be
    class Data,MONGO,JDBC,FS data
    class ECM,ecmIn,ecmOut ecm